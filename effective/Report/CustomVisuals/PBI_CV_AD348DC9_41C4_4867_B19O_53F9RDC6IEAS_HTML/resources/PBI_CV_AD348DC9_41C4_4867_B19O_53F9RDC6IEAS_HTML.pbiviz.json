{"visual":{"name":"PowerBI-visuals-forcasting-ARIMA","displayName":"Forecasting with ARIMA","guid":"PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML","visualClassName":"Visual","version":"1.2.1","description":"<span> Time series forecasting is the use of a model to predict future values based on previously observed values. Current visual implements well known Autoregressive Integrated Moving Average (ARIMA) method for the forecasting. Both seasonal and non-seasonal modeling is supported. You can control the algorithm parameters and the visual attributes to suit your needs.<br/><br/><span style='font-style:italic'>Service prerequisites:</span> R-powered custom visual is used in service seamlessly<br/><br /><span style='font-style:italic'>Desktop prerequisites:</span> To run R scripts in Power BI Desktop, you must separately install R on your local computer.<br />You can download and install R for free from the <a href='https://mran.revolutionanalytics.com/download/'>Revolution Open download page</a> or the <a href='https://cran.r-project.org/bin/windows/base/'>CRAN Repository</a><br /><br /> <span style='font-style:italic'> R package dependencies(auto-installed): </span> graphics, scales, forecast, zoo,  htmlWidgets, XML, plotly <br /><br /> <span style='font-style:italic'> Supports R versions: </span> R 3.3.1, R 3.3.0, MRO 3.3.1, MRO 3.3.0, MRO 3.2.2, 3.4.x  <br /></span>","supportUrl":"http://community.powerbi.com/","gitHubUrl":"https://github.com/Microsoft/powerbi-visuals-forcastingarima"},"apiVersion":"1.11.0","author":{"name":"Microsoft","email":"pbicvsupport@microsoft.com"},"assets":{"icon":"assets/icon.png"},"externalJS":["node_modules/powerbi-visuals-utils-dataviewutils/lib/index.js"],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Date","description":"Equally spaced date values","kind":"Grouping","name":"Date"},{"displayName":"Value","description":"Numeric column","kind":"Measure","name":"Value"}],"dataViewMappings":[{"conditions":[{"Date":{"max":1},"Value":{"max":1}}],"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"Date"}},{"for":{"in":"Value"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"html","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"# Copyright (c) Microsoft Corporation.  All rights reserved.\r\n\r\n# Third Party Programs. This software enables you to obtain software applications from other sources. \r\n# Those applications are offered and distributed by third parties under their own license terms.\r\n# Microsoft is not developing, distributing or licensing those applications to you, but instead, \r\n# as a convenience, enables you to use this software to obtain those applications directly from \r\n# the application providers.\r\n# By using the software, you acknowledge and agree that you are obtaining the applications directly\r\n# from the third party providers and under separate license terms, and that it is your responsibility to locate, \r\n# understand and comply with those license terms.\r\n# Microsoft grants you no license rights for third-party software or applications that is obtained using this software.\r\n\r\n#\r\n# WARNINGS:   \r\n#\r\n# CREATION DATE: 24/7/2016\r\n#\r\n# LAST UPDATE: 25/04/2018\r\n#\r\n# VERSION: 1.2.1\r\n#\r\n# R VERSION TESTED: 3.4.1\r\n# \r\n# AUTHOR: pbicvsupport@microsoft.com\r\n#\r\n# REFERENCES: https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average, https://www.otexts.org/fpp/8\r\n\r\n############### Utility functions ###############\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\", sep=\"\"))\r\n}\r\n\r\nlibraryRequireInstall(\"XML\")\r\nlibraryRequireInstall(\"htmlwidgets\")\r\n\r\ninternalSaveWidget <- function(widget, fname)\r\n{\r\n  tempFname = paste(fname, \".tmp\", sep=\"\")\r\n  htmlwidgets::saveWidget(widget, file = tempFname, selfcontained = FALSE)\r\n  FlattenHTML(tempFname, fname)\r\n}\r\n\r\nFlattenHTML <- function(fnameIn, fnameOut)\r\n{\r\n  # Read and parse HTML file\r\n  # Embed all js and css files into one unified file\r\n  \r\n  if(!file.exists(fnameIn))\r\n    return(FALSE)\r\n  \r\n  dir = dirname(fnameIn)\r\n  html = htmlTreeParse(fnameIn, useInternal = TRUE)\r\n  top = xmlRoot(html)\r\n  \r\n  # extract all <script> tags with src value\r\n  srcNode=getNodeSet(top, '//script[@src]')\r\n  for (node in srcNode)\r\n  {\r\n    b = xmlAttrs(node)\r\n    fname = file.path(dir, b['src'])\r\n    alternateSrc = FindSrcReplacement(fname)\r\n    if (!is.null(alternateSrc))\r\n    {\r\n      s = alternateSrc\r\n      names(s) = 'src'\r\n      newNode = xmlNode(\"script\",attrs = s)\r\n      replaceNodes(node, newNode)\r\n    }else{\r\n      str=ReadFileForEmbedding(fname);\r\n      if (!is.null(str))\r\n      {      \r\n        newNode = xmlNode(\"script\", str, attrs = c(type = \"text/javascript\"))\r\n        replaceNodes(node, newNode)\r\n      }\r\n    }\r\n  }\r\n  \r\n  # extract all <link> tags with src value\r\n  linkNode=getNodeSet(top, '//link[@href]')\r\n  for (node in linkNode)\r\n  {\r\n    b = xmlAttrs(node)\r\n    fname = file.path(dir, b['href'])\r\n    str = ReadFileForEmbedding(fname, FALSE);\r\n    if (!is.null(str))\r\n    {\r\n      newNode = xmlNode(\"style\", str)\r\n      replaceNodes(node, newNode)\r\n    }\r\n  }\r\n  \r\n  saveXML(html, file = fnameOut)\r\n  return(TRUE)\r\n}\r\n\r\nReadFileForEmbedding <- function(fname, addCdata = TRUE)\r\n{\r\n  data = ReadFullFile(fname)\r\n  if (is.null(data))\r\n    return(NULL)\r\n\r\n  str = paste(data, collapse ='\\n')\r\n  if (addCdata) {\r\n    str = paste(cbind('// <![CDATA[', str,'// ]]>'), collapse ='\\n')\r\n  }\r\n  return(str)\r\n}\r\n\r\nReadFullFile <- function(fname)\r\n{\r\n  if(!file.exists(fname))\r\n    return(NULL)\r\n  \r\n  con = file(fname, open = \"r\")\r\n  data = readLines(con)\r\n  close(con)\r\n  return(data)\r\n}\r\n\r\nFindSrcReplacement <- function(str)\r\n{\r\n  # finds reference to 'plotly' js and replaces with a version from CDN\r\n  # This allows the HTML to be smaller, since this script is not fully embedded in it\r\n  str <- iconv(str, to=\"UTF-8\")\r\n  pattern = \"plotlyjs-(\\\\w.+)/plotly-latest.min.js\"\r\n  match1=regexpr(pattern, str)\r\n  attr(match1, 'useBytes') <- FALSE\r\n  strMatch=regmatches(str, match1, invert = FALSE)\r\n  if (length(strMatch) == 0) return(NULL)\r\n  \r\n  pattern2 = \"-(\\\\d.+)/\"\r\n  match2 = regexpr(pattern2, strMatch[1])\r\n  attr(match2, 'useBytes') <- FALSE\r\n  strmatch = regmatches(strMatch[1], match2)\r\n  if (length(strmatch) == 0) return(NULL)\r\n  \r\n  # CDN url is https://cdn.plot.ly/plotly-<Version>.js\r\n  # This matches the specific version used in the plotly package used.\r\n  verstr = substr(strmatch, 2, nchar(strmatch)-1)\r\n  str = paste('https://cdn.plot.ly/plotly-', verstr,'.min.js', sep='')\r\n  return(str)\r\n}\r\n\r\n\r\n#ReadFullFileReplaceString\r\nReadFullFileReplaceString <- function(fnameIn, fnameOut, sourceString,targetString)\r\n{\r\n  if(!file.exists(fnameIn))\r\n    return(NULL)\r\n  \r\n  tx  <- readLines(fnameIn)\r\n  tx2  <- gsub(pattern = sourceString, replace = targetString, x = tx)\r\n  writeLines(tx2, con = fnameOut)\r\n}\r\n#################################################\r\n\r\n\r\n\r\n\r\n\r\n\r\nSys.setlocale(\"LC_ALL\",\"English\") # internationalization\r\n\r\n############ User Parameters #########\r\n\r\n############ User Parameters #########\r\n\r\n##PBI_PARAM: Should additional info about the forcasting method be displayed?\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowInfo = TRUE\r\nif(exists(\"settings_additional_params_show\"))\r\n  showInfo = settings_additional_params_show\r\n\r\n##PBI_PARAM: Output information criteria\r\n#Type:enum, Default:\"none\", Range:NA, PossibleValues:none, AIC,BIC,AICc, Remarks: NA\r\ninfoCriteria = \"none\"\r\nif(exists(\"settings_additional_params_infoCriteria\"))\r\n  infoCriteria = settings_additional_params_infoCriteria\r\n\r\n##PBI_PARAM: Forecast length\r\n#Type:integer, Default:NULL, Range:NA, PossibleValues:NA, Remarks: NULL means choose forecast length automatically\r\nforecastLength = 10\r\nif(exists(\"settings_forecastPlot_params_forecastLength\"))\r\n{\r\n  forecastLength = as.numeric(settings_forecastPlot_params_forecastLength)\r\n  if(is.na(forecastLength))\r\n    forecastLength = 10\r\n  forecastLength = round(max(min(forecastLength, 1e+6), 1))\r\n}\r\n\r\n##PBI_PARAM: Confidence level\r\n#Type:enum, Default:\"0.85\", Range:NA, PossibleValues:0, 0.5 etc, Remarks: NA\r\nconfInterval1 = 0.85\r\nif(exists(\"settings_forecastPlot_params_confInterval1\"))\r\n{\r\n  confInterval1 = as.numeric(settings_forecastPlot_params_confInterval1)\r\n}\r\n\r\n\r\n##PBI_PARAM: Confidence level\r\n#Type:enum, Default:\"0.95\", Range:NA, PossibleValues:0, 0.5 etc, Remarks: NA\r\nconfInterval2 = 0.95\r\nif(exists(\"settings_forecastPlot_params_confInterval2\"))\r\n{\r\n  confInterval2 = as.numeric(settings_forecastPlot_params_confInterval2)\r\n}\r\n\r\n\r\n##PBI_PARAM: Does the model assume seasonality? \r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nwithSeasonality = TRUE \r\nif(exists(\"settings_seasonality_params_show\"))\r\n  withSeasonality = settings_seasonality_params_show\r\n\r\n\r\n##PBI_PARAM target Season\r\n#Type: string, Default:\"automatic\", Range:NA, PossibleValues:\"automatic\",\"hour\",\"day\",\"week\", ...\r\ntargetSeason = \"automatic\"\r\nif(exists(\"settings_seasonality_params_targetSeason\"))\r\n  targetSeason = settings_seasonality_params_targetSeason\r\n\r\n##PBI_PARAM target frequency (samples per period)\r\n#Type: numeric, Default:12 , Range:[2,10^6], PossibleValues:NA\r\nknownFrequency = 12\r\nif(exists(\"settings_seasonality_params_knownFrequency\")) \r\n  knownFrequency = min(1000000, max(2, settings_seasonality_params_knownFrequency))\r\n\r\n\r\n##PBI_PARAM The maximal order of the  autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxp  = 3\r\nif(exists(\"settings_model_params_maxp\")) \r\n  maxp = as.numeric(settings_model_params_maxp)\r\n\r\n##PBI_PARAM The maximal order of the  moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxq  = 3\r\nif(exists(\"settings_model_params_maxq\")) \r\n  maxq = as.numeric(settings_model_params_maxq)\r\n\r\n##PBI_PARAM The maximal degree of the differentiation\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\"\r\nmaxd  = 2\r\nif(exists(\"settings_model_params_maxd\")) \r\n  maxd = as.numeric(settings_model_params_maxd)\r\n\r\n##PBI_PARAM The maximal order of the seasonal autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxP  = 2 \r\nif(exists(\"settings_model_params_maxP\")) \r\n  maxP = as.numeric(settings_model_params_maxP)\r\n\r\n##PBI_PARAM The maximal order of the seasonal moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nmaxQ  = 2\r\nif(exists(\"settings_model_params_maxQ\")) \r\n  maxQ = as.numeric(settings_model_params_maxQ)\r\n\r\n##PBI_PARAM The maximal degree of the seasonal differentiation\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\"\r\nmaxD  = 1\r\nif(exists(\"settings_model_params_maxD\")) \r\n  maxD = as.numeric(settings_model_params_maxD)\r\n\r\n##PBI_PARAM: Should the ARIMA model include a linear drift term?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nallowDrift  = TRUE\r\nif(exists(\"settings_model_params_allowDrift\")) \r\n  allowDrift = (settings_model_params_allowDrift)\r\n\r\n##PBI_PARAM: Should the ARIMA model include a mean term?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nallowMean  = FALSE\r\nif(exists(\"settings_model_params_allowMean\")) \r\n  allowMean = settings_model_params_allowMean\r\n\r\n##PBI_PARAM: If TRUE, will do stepwise selection (faster). Otherwise, it searches over all models (can be very slow).\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nstepwiseSelection  = TRUE\r\nif(exists(\"settings_model_params_stepwiseSelection\")) \r\n  stepwiseSelection = settings_model_params_stepwiseSelection\r\n\r\n##PBI_PARAM Box-Cox transformation\r\n#Type: enum/string, Default:\"off\", Range:NA, PossibleValues:\"off\",\"manual\",\"automatic\"\r\nboxCoxTransform = \"off\"\r\nif(exists(\"settings_model_params_boxCoxTransform\")) \r\n  boxCoxTransform = settings_model_params_boxCoxTransform\r\n\r\n##PBI_PARAM Box-Cox transformation parameter\r\n#Type: numeric, Default:0, Range:[-1,2], PossibleValues:NA\r\nlambda  = 0\r\nif(exists(\"settings_model_params_lambda\")) \r\n  lambda = max(-0.5,min(settings_model_params_lambda,1.5))\r\n\r\n##PBI_PARAM: User model? \r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nuserModel  = FALSE\r\nif(exists(\"settings_userModel_params_show\")) \r\n  userModel = settings_userModel_params_show\r\n\r\n##PBI_PARAM The order of the autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\np  = 1\r\nif(exists(\"settings_userModel_params_p\")) \r\n  p = as.numeric(settings_userModel_params_p)\r\n\r\n##PBI_PARAM The maximal order of the moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nq  = 1\r\nif(exists(\"settings_userModel_params_q\")) \r\n  q = as.numeric(settings_userModel_params_q)\r\n\r\n##PBI_PARAM The degree of the differencing\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nd  = 1\r\nif(exists(\"settings_userModel_params_d\")) \r\n  d = as.numeric(settings_userModel_params_d)\r\n\r\n##PBI_PARAM The  order of the seasonal autoregressive component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nP  = 1\r\nif(exists(\"settings_userModel_params_P\")) \r\n  P = as.numeric(settings_userModel_params_P)\r\n\r\n##PBI_PARAM The maximal order of the seasonal moving average component\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nQ  = 1\r\nif(exists(\"settings_userModel_params_Q\")) \r\n  Q = as.numeric(settings_userModel_params_Q)\r\n\r\n##PBI_PARAM The degree of the differencing\r\n#Type: enum/string, Default:\"2\", Range:NA, PossibleValues:\"0\",\"1\",\"2\",\"3\"\r\nD  = 0\r\nif(exists(\"settings_userModel_params_D\")) \r\n  D = as.numeric(settings_userModel_params_D)\r\n\r\n##PBI_PARAM Color of time series line\r\n#Type:string, Default:\"orange\", Range:NA, PossibleValues:\"orange\",\"blue\",\"green\",\"black\"\r\npointsCol = \"blue\"\r\nif(exists(\"settings_graph_params_dataCol\"))\r\n  pointsCol = settings_graph_params_dataCol\r\n\r\n##PBI_PARAM Color of forecast line\r\n#Type:string, Default:\"red\", Range:NA, PossibleValues:\"red\",\"blue\",\"green\",\"black\"\r\nforecastCol = \"orange\"\r\nif(exists(\"settings_graph_params_forecastCol\"))\r\n  forecastCol = settings_graph_params_forecastCol\r\n\r\n#PBI_PARAM Transparency of scatterplot points\r\n#Type:numeric, Default:0.4, Range:[0,1], PossibleValues:NA, Remarks: NA\r\ntransparency = 1\r\nif(exists(\"settings_graph_params_percentile\"))\r\n  transparency = as.numeric(settings_graph_params_percentile) / 100\r\n\r\n##PBI_PARAM: export out data to HTML?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nkeepOutData = FALSE\r\nif(exists(\"settings_export_params_show\"))\r\n  keepOutData = settings_export_params_show \r\n\r\n##PBI_PARAM: method of export interface\r\n#Type: string , Default:\"copy\",  Range:NA, PossibleValues:\"copy\", \"download\",  Remarks: NA\r\nexportMethod = \"copy\"\r\nif(exists(\"settings_export_params_method\"))\r\n  exportMethod = settings_export_params_method \r\n\r\n##PBI_PARAM: limit the out table exported\r\n#Type: string , Default:1000,  Range:NA, PossibleValues:\"1000\", \"10000\", Inf,  Remarks: NA\r\nlimitExportSize = 1000\r\nif(exists(\"settings_export_params_limitExportSize\"))\r\n  limitExportSize = as.numeric(settings_export_params_limitExportSize)\r\n\r\n\r\n\r\n###############Library Declarations###############\r\n\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\", sep = \"\"))\r\n}\r\n\r\n\r\nlibraryRequireInstall(\"scales\")\r\nlibraryRequireInstall(\"forecast\")\r\nlibraryRequireInstall(\"zoo\")\r\nlibraryRequireInstall(\"ggplot2\");\r\nlibraryRequireInstall(\"plotly\")\r\nlibraryRequireInstall(\"caTools\")\r\n\r\n###############Internal parameters definitions#################\r\n\r\n#PBI_PARAM Minimal number of points\r\n#Type:integer, Default:10, Range:[0,], PossibleValues:NA, Remarks: NA\r\nminPoints = 10\r\n\r\n#PBI_PARAM Shaded band for confidence interval\r\n#Type:logical, Default:TRUE, Range:NA, PossibleValues:NA, Remarks: NA\r\nfillConfidenceLevels=TRUE\r\n\r\n#PBI_PARAM Size of points on the plot\r\n#Type:numeric, Default: 1 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\npointCex = 1\r\nif(exists(\"settings_graph_params_weight\"))\r\n  pointCex = as.numeric(settings_graph_params_weight)/10\r\n\r\n#PBI_PARAM Size of subtitle on the plot\r\n#Type:numeric, Default: 0.75 , Range:[0.1,5], PossibleValues:NA, Remarks: NA\r\ncexSub = 1\r\nif(exists(\"settings_additional_params_textSize\"))\r\n  cexSub = as.numeric(settings_additional_params_textSize)/12\r\n\r\n#PBI_PARAM Color for the text string of info \r\n#Type:string, Default: \"brown\" , Range:NA, PossibleValues:NA, Remarks: NA\r\ninfoTextColor = \"brown\"\r\nif(exists(\"settings_additional_params_textColor\"))\r\n  infoTextColor = settings_additional_params_textColor\r\n\r\nif(confInterval1 > confInterval2)\r\n{#switch places\r\n  temp = confInterval1\r\n  confInterval1 = confInterval2\r\n  confInterval2 = temp\r\n}\r\n\r\nlowerConfInterval = confInterval1\r\nupperConfInterval = confInterval2\r\n\r\n\r\n#PBI_PARAM Size of labels on axes\r\n#Type:numeric , Default:12, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeLabel = 12\r\n\r\n#PBI_PARAM Size of warnings font\r\n#Type:numeric , Default:cexSub*10, Range:NA, PossibleValues:[1,50], Remarks: NA\r\nsizeWarn = cexSub*8\r\n\r\n#PBI_PARAM Size of ticks on axes \r\nsizeTicks = 8\r\n\r\n#PBI_PARAM opacity of conf interval color\r\ntransparencyConfInterval = 0.3 \r\n\r\n##PBI_PARAM: Should warnings text be displayed?\r\n#Type:logical, Default:FALSE, Range:NA, PossibleValues:NA, Remarks: NA\r\nshowWarnings = FALSE #changed in 1.0.2 (HTML-based) to be FALSE by default \r\n\r\n###############Internal functions definitions#################\r\n\r\n# tiny function to deal with verl long strings on plot\r\ncutStr2Show = function(strText, strCex = 0.8, abbrTo = 100, isH = TRUE, maxChar = 3, partAvailable = 1)\r\n{\r\n  # partAvailable, wich portion of window is available, in [0,1]\r\n  if(is.null(strText))\r\n    return (NULL)\r\n  \r\n  SCL = 0.075*strCex/0.8\r\n  pardin = par()$din\r\n  gStand = partAvailable*(isH*pardin[1]+(1-isH)*pardin[2]) /SCL\r\n  \r\n  # if very very long abbreviate\r\n  if(nchar(strText)>abbrTo && nchar(strText)> 1)\r\n    strText = abbreviate(strText, abbrTo)\r\n  \r\n  # if looooooong convert to lo...\r\n  if(nchar(strText)>round(gStand) && nchar(strText)> 1)\r\n    strText = paste(substring(strText,1,floor(gStand)),\"...\",sep=\"\")\r\n  \r\n  # if shorter than maxChar remove \r\n  if(gStand<=maxChar)\r\n    strText = NULL\r\n  \r\n  return(strText) \r\n}\r\n\r\n\r\n# Find number of ticks on X axis \r\nFindTicksNum = function(n,f, flag_ggplot = TRUE)\r\n{\r\n  factorGG = (if(flag_ggplot) 0.525 else 1)\r\n  \r\n  tn = 10* factorGG # default minimum\r\n  mtn = 20 * factorGG # default max\r\n  \r\n  D = 2 # tick/inch\r\n  numCircles = n/f\r\n  xSize = par()$din[1]\r\n  tn = min(max(round(xSize*D*factorGG),tn),mtn)\r\n  return(tn) \r\n}\r\n\r\n#format labels on X-axis automatically \r\nflexFormat = function(dates, orig_dates, freq = 1, myformat = NULL)\r\n{\r\n  \r\n  days=(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  months = days/30\r\n  years = days/365.25\r\n  \r\n  \r\n  constHour = length(unique(orig_dates$hour))==1\r\n  constMin = length(unique(orig_dates$min))==1\r\n  constSec = length(unique(orig_dates$sec))==1\r\n  constMon = length(unique(orig_dates$mon))==1\r\n  \r\n  timeChange = any(!constHour,!constMin,!constSec)\r\n  \r\n  if(is.null(myformat))\r\n  {\r\n    if(years > 10){\r\n      if(constMon)\r\n      {\r\n        myformat = \"%Y\" #many years => only year :2001\r\n      }else{\r\n        myformat = \"%m/%y\" #many years + months :12/01\r\n      }\r\n    }else{\r\n      if(years > 1 && N < 50){\r\n        myformat = \"%b %d, %Y\" #several years, few samples:Jan 01, 2010\r\n      }else{\r\n        if(years > 1){\r\n          myformat = \"%m/%d/%y\" #several years, many samples: 01/20/10\r\n        }else{\r\n          if(years <= 1 && !timeChange)\r\n            myformat = \"%b %d\" #1 year,no time: Jan 01\r\n        }  \r\n      }\r\n    }\r\n  }\r\n  if(is.null(myformat) && timeChange)\r\n    if(years > 1){\r\n      myformat = \"%m/%d/%y %H:%M\" # 01/20/10 12:00\r\n    }else{\r\n      if(days > 1){\r\n        myformat = \"%b %d, %H:%M\" # Jan 01 12:00\r\n      }else{\r\n        if(days <= 1){\r\n          myformat = \"%H:%M\" # Jan 01 12:00\r\n        }  \r\n      }\r\n    }\r\n  if(!is.null(myformat)){\r\n    if(myformat == \"%Y,Q%q\")\r\n      dates = as.yearqtr(dates)\r\n    dates1= format(dates,  myformat)\r\n  }else{\r\n    dates1 = as.character(1:length(dates)) # just id \r\n  }\r\n  return(dates1)\r\n}\r\n\r\n\r\n# verify if \"perSeason\" is good for \"frequency\" parameter\r\nfreqSeason1 = function(seasons, perSeason)\r\n{\r\n  if((seasons > 5 && perSeason > 3) || (seasons > 2 && perSeason > 7))\r\n    return (perSeason)\r\n  \r\n  return(1)\r\n}\r\n\r\n\r\n# find frequency using the dates, targetS is a \"recommended\" seasonality \r\nfindFreqFromDates1 = function(dates, targetS = \"Automatic\")\r\n{\r\n  freq = 1\r\n  N = length(dates)\r\n  nnn = c(\"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\")\r\n  seasons = rep(NaN, 6)\r\n  names(seasons) = nnn\r\n  perSeason = seasons\r\n  \r\n  seasons[\"day\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  seasons[\"hour\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"hours\"))\r\n  seasons[\"week\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"weeks\"))\r\n  seasons[\"month\"] = seasons[\"day\"]/30\r\n  seasons[\"year\"] = seasons[\"day\"]/365.25\r\n  seasons[\"quarter\"] = seasons[\"year\"]*4\r\n  \r\n  perSeason = N/seasons\r\n  \r\n  if(targetS!=\"automatic\") # target \r\n    freq = perSeason[targetS]\r\n  \r\n  if(freq < 2) # if TRUE, target season factor is not good \r\n    freq = 1\r\n  \r\n  for( s in rev(nnn)) # check year --> quarter --> etc\r\n    if(freq == 1 )\r\n      freq = freqSeason1(seasons[s],perSeason[s])\r\n  \r\n  return(round(freq))\r\n}\r\n\r\n#get valid frequency parameter, based on input from user \r\ngetFrequency1 = function(parsed_dates, values, tS, f)\r\n{\r\n  myFreq = f\r\n  grp = c(\"automatic\",\"none\",\"manual\")\r\n  \r\n  if(!(tS %in% c(\"autodetect from value\",\"none\",\"manual\"))) #detect from date\r\n  {  \r\n    myFreq = findFreqFromDates1(parsed_dates, targetS = tS)\r\n  }else{\r\n    if(tS == \"none\")\r\n    { myFreq = 1}\r\n    else\r\n    {# NOT YET IMPLEMENTED\r\n      # if(tS == \"autodetect from value\")\r\n      #   myFreq = freqFromValue1(values)\r\n    }\r\n  }\r\n  numPeriods = floor(length(values)/myFreq)\r\n  if(numPeriods< 2)\r\n    myFreq = findFreqFromDates1(parsed_dates, targetS = \"automatic\")\r\n  return(myFreq)\r\n}\r\n\r\n#format info string \r\nGetFitMethodString = function(fit,withSeasonality, infoCriteria = \"none\")\r\n{\r\n  \r\n  arma = fit$arma\r\n  \r\n  resString = as.character(arimaorder(fit))\r\n  \r\n  skey = c(\"p\",\"d\",\"q\",\"P\",\"D\",\"Q\",\"m\")\r\n  skey = skey[1:length(resString)]\r\n  skey = paste(skey, collapse = \",\")\r\n  \r\n  resString = paste(\"ARIMA: (\",skey,\") = (\",paste(resString,collapse = \",\"),\")\",sep = \"\")\r\n  # add more info \r\n  if(infoCriteria != \"none\")\r\n  {\r\n    if(infoCriteria == \"AIC\")\r\n      resString = paste(resString, \"; AIC = \", as.character(round(fit$aic,2)), sep = \"\")\r\n    else\r\n      if(infoCriteria == \"AICc\")\r\n        resString = paste(resString, \"; AICc = \", as.character(round(fit$aicc,2)), sep = \"\")\r\n      else\r\n        if(infoCriteria == \"BIC\")\r\n          resString = paste(resString, \"; BIC = \", as.character(round(fit$bic,2)), sep = \"\")\r\n  }\r\n  \r\n  return(resString)\r\n  \r\n}\r\n\r\n# find lambda for Box-Cox transform\r\nFindBoxCoxLambda = function(timeSeries, boxCoxTransform, lambda = NULL,  mymethod = \"loglik\")\r\n{\r\n  if(boxCoxTransform == \"off\")\r\n    return(NULL)\r\n  if(boxCoxTransform == \"manual\")\r\n    return(lambda)\r\n  if(boxCoxTransform == \"automatic\")\r\n    lambda=BoxCox.lambda(timeSeries, method = mymethod, lower = -1, upper = 2)\r\n  return (lambda)\r\n}\r\n\r\n\r\ngetAngleXlabels = function(mylabels)\r\n{\r\n  NL = length(mylabels)\r\n  NC = nchar(mylabels[1]) * 1.1\r\n  \r\n  lenPerTick = par()$din[1] / (NL * NC)\r\n  \r\n  #lot of space -> 0 \r\n  if(lenPerTick > 0.15)\r\n    return(0)\r\n  \r\n  # no space --> -90\r\n  if(lenPerTick < 0.070)\r\n    return(90)\r\n  \r\n  # few space --> - 45\r\n  return(45)\r\n  \r\n}\r\n\r\nConvertDF64encoding = function (df, withoutEncoding = FALSE)\r\n{\r\n  header_row <- paste(names(df), collapse=\", \")\r\n  tab <- apply(df, 1, function(x)paste(x, collapse=\", \"))\r\n  \r\n  if(withoutEncoding){\r\n    text <- paste(c(header_row, tab), collapse=\"\\n\")\r\n    x <- text\r\n  }\r\n  else\r\n  {\r\n    text <- paste(c(header_row, tab), collapse=\"\\n\")\r\n    x <- caTools::base64encode(text)\r\n  }\r\n  return(x)\r\n}\r\n\r\n\r\nKeepOutDataInHTML = function(df, htmlFile = 'out.html', exportMethod = \"copy\", limitExportSize = 1000)\r\n{\r\n  if(nrow(df)>limitExportSize)\r\n    df = df[1:limitExportSize,]\r\n  \r\n  outDataString64 = ConvertDF64encoding(df)\r\n  \r\n  linkElem = '\\n<a href=\"\"  download=\"data.csv\"  style=\"position: absolute; top:0px; left: 0px; z-index: 20000;\" id = \"mydataURL\">export</a>\\n'\r\n  updateLinkElem = paste('<script>\\n link_element = document.getElementById(\"mydataURL\");link_element.href = outDataString64href;', '\\n</script> ', sep =' ')\r\n  var64 = paste('<script> outDataString64 =\"', outDataString64, '\"; </script>', sep =\"\")\r\n  var64href = paste('<script> outDataString64href =\"data:;base64,', outDataString64, '\"; </script>', sep =\"\")\r\n  \r\n  buttonElem = '<button style=\"position: absolute; top:0px; left: 0px; z-index: 20000;\"  onclick=\"myFunctionCopy(1)\">copy to clipboard</button>'\r\n  funcScript = '<script> \r\n  function myFunctionCopy(is64) \r\n  {\r\n  const el = document.createElement(\"textarea\");\r\n  if(is64)\r\n  {\r\n  el.value = atob(outDataString64);\r\n  }\r\n  else\r\n  {\r\n  el.value = outDataStringPlane;\r\n  }\r\n  document.body.appendChild(el);\r\n  el.select();\r\n  document.execCommand(\"copy\");\r\n  document.body.removeChild(el);};\t\r\n  </script>'\r\n  \r\n  if(exportMethod == \"copy\")\r\n    endOfBody = paste(var64,funcScript, buttonElem,'\\n</body>',sep =\"\")\r\n  else#\"download\"\r\n    endOfBody = paste(linkElem,var64, var64href,updateLinkElem,'\\n</body>',sep =\"\")\r\n  \r\n  ReadFullFileReplaceString('out.html', 'out.html', '</body>', endOfBody)\r\n  \r\n}\r\n\r\n\r\n###############Upfront input correctness validations (where possible)#################\r\npbiWarning = NULL\r\n\r\nif(!exists(\"Date\") || !exists(\"Value\"))\r\n{\r\n  dataset=data.frame()\r\n  pbiWarning  = cutStr2Show(\"Both 'Date' and 'Value' fields are required.\", strCex = 1.55, partAvailable = 0.95)\r\n  timeSeries=ts()\r\n  showWarnings=TRUE\r\n}else{\r\n  dataset= cbind(Date,Value)\r\n  dataset<-dataset[complete.cases(dataset),] #remove corrupted rows\r\n  \r\n  labTime = \"Time\"\r\n  labValue=names(dataset)[ncol(dataset)]\r\n  \r\n  N=nrow(dataset)\r\n  \r\n  \r\n  if(N==0 && exists(\"Date\") && nrow(Date)>0 &&  exists(\"Value\")){\r\n    \r\n    pbiWarning1  = cutStr2Show(\"Wrong date type.\", strCex = sizeWarn/6, partAvailable = 0.85)\r\n    pbiWarning2 = cutStr2Show(\"Only 'Date', 'Time', 'Date/Time' are allowed without hierarchy. \", strCex = sizeWarn/6, partAvailable = 0.85)\r\n    pbiWarning = paste(pbiWarning1, pbiWarning2, pbiWarning, sep =\"<br>\")\r\n    \r\n    timeSeries=ts()\r\n    showWarnings=TRUE\r\n  }else {\r\n    if(N < minPoints)\r\n    {\r\n      timeSeries=ts()\r\n      showWarnings=TRUE\r\n    }\r\n    else\r\n    {\r\n      dataset = dataset[order(dataset[,1]),]\r\n      parsed_dates=strptime(dataset[,1],\"%Y-%m-%dT%H:%M:%S\",tz=\"UTC\")\r\n      labTime = names(Date)[1]\r\n      \r\n      if((any(is.na(parsed_dates))))\r\n      {\r\n        pbiWarning1  = cutStr2Show(\"Wrong or corrupted 'Date'.\", strCex = sizeWarn/6, partAvailable = 0.85)\r\n        pbiWarning2  = cutStr2Show(\"Only 'Date', 'Time', 'Date/Time' types are allowed without hierarchy\", strCex = sizeWarn/6, partAvailable = 0.85)\r\n        pbiWarning = paste(pbiWarning1, pbiWarning2, pbiWarning, sep =\"<br>\")\r\n        timeSeries=ts()\r\n        showWarnings=TRUE\r\n      }\r\n      else\r\n      {\r\n        interval = difftime(parsed_dates[length(parsed_dates)],parsed_dates[1])/(length(parsed_dates)-1) # force equal spacing \r\n        \r\n        if(withSeasonality==FALSE)\r\n          targetSeason = \"none\"\r\n        \r\n        myFreq = getFrequency1(parsed_dates, values = dataset[,2], tS = targetSeason, f = knownFrequency)\r\n        \r\n        \r\n        if(myFreq < 2)\r\n          withSeasonality = FALSE\r\n        \r\n        if(withSeasonality == FALSE)\r\n        {\r\n          maxP = maxQ = maxD = P = Q = D = 0 \r\n        }\r\n        \r\n        \r\n        timeSeries=ts(data = dataset[,2], start=1, frequency = round(myFreq))\r\n      }\r\n      \r\n    }\r\n  }\r\n}\r\n\r\n##############Main Visualization script###########\r\n\r\npbiInfo = NULL\r\n\r\nif(length(timeSeries)>=minPoints) {\r\n  \r\n  lambda = FindBoxCoxLambda(timeSeries, boxCoxTransform, lambda)\r\n  \r\n  fit = NULL\r\n  #if user model fails do auto.arima\r\n  if(userModel)\r\n  {\r\n    result <- tryCatch({\r\n      fit = suppressWarnings(Arima(timeSeries, order = c(p,d,q), seasonal = c(P,D,Q), \r\n                                   include.mean=allowMean, include.drift=allowDrift, \r\n                                   method = \"ML\", lambda=lambda))\r\n    }, warning = function(war) {\r\n      \r\n      # warning handler picks up where error was generated\r\n      print(paste(\"MY_WARNING:  \",war))\r\n      return(\"Arima_warning\")\r\n      \r\n    }, error = function(err) {\r\n      \r\n      # error handler picks up where error was generated\r\n      print(paste(\"MY_ERROR: \",err))\r\n      return(\"Arima_error\")\r\n      \r\n    }, finally = {\r\n      \r\n    }) # END tryCatch\r\n    \r\n  }\r\n  \r\n  if(is.null(fit))\r\n    fit = auto.arima(timeSeries, max.p = maxp, max.q = maxq, max.d = maxd, \r\n                     max.P = maxP, max.Q = maxQ, max.D = maxD,\r\n                     seasonal= withSeasonality,allowdrift=allowDrift, allowmean=allowMean, lambda=lambda,\r\n                     max.order=4, parallel = FALSE, stepwise = stepwiseSelection)\r\n  \r\n  \r\n  \r\n  fit$method = GetFitMethodString(fit,withSeasonality, infoCriteria)\r\n  \r\n  if(lowerConfInterval <= 0.1)\r\n    lowerConfInterval = NULL;\r\n  \r\n  prediction = forecast(fit, level=c(lowerConfInterval,upperConfInterval), h=forecastLength)\r\n  \r\n  lastValue = tail(prediction$x,1)\r\n  \r\n  prediction$mean=ts(c(lastValue,prediction$mean), \r\n                     frequency = frequency(prediction$mean), \r\n                     end=end(prediction$mean))\r\n  # \r\n  prediction$upper=rbind(c(lastValue,lastValue),prediction$upper)\r\n  #\r\n  prediction$lower=rbind(c(lastValue,lastValue),prediction$lower)\r\n  \r\n  if(showInfo)\r\n  {\r\n    pbiInfo=paste(pbiInfo,\"\", fit$method, sep=\"\")\r\n    #pbiInfo = cutStr2Show(pbiInfo,strCex = cexSub, isH = TRUE, maxChar = 20)\r\n    pbiInfo= cutStr2Show(pbiInfo, strCex = sizeWarn / 6, isH = TRUE, partAvailable = 0.9, maxChar = 20)\r\n  }\r\n  \r\n  \r\n  labTime = cutStr2Show(labTime, strCex = sizeLabel/6, isH = TRUE, partAvailable = 0.8)\r\n  labValue = cutStr2Show(labValue, strCex = sizeLabel/6, isH = FALSE, partAvailable = 0.8)\r\n  \r\n  NpF = (length(parsed_dates))+forecastLength\r\n  freq = frequency(timeSeries)\r\n  \r\n  #format  x_with_f\r\n  numTicks = FindTicksNum(NpF,freq) # find based on plot size\r\n  \r\n  x_with_f = as.POSIXlt(seq(from=parsed_dates[1], to = (parsed_dates[1]+interval*(length(parsed_dates)+forecastLength)), length.out = numTicks))\r\n  x_with_forcast_formatted = flexFormat(dates = x_with_f, orig_dates = parsed_dates, freq = freq)\r\n  \r\n  \r\n  x_full = as.POSIXlt(seq(from=parsed_dates[1], to = tail(parsed_dates,1), length.out = length(parsed_dates)))\r\n  f_full = as.POSIXlt(seq(from=tail(parsed_dates,1), to = (tail(parsed_dates,1)+interval*(forecastLength)), length.out = forecastLength+1))\r\n  \r\n  # correction = (NpF-1)/(numTicks-1) # needed due to subsampling of ticks\r\n  \r\n  if(!showWarnings)\r\n  {\r\n    \r\n    #HTML\r\n    #historical data\r\n    x1 = seq(1,length(prediction$x))\r\n    y1 = as.numeric(prediction$x)\r\n    \r\n    p1a<-ggplot(data=NULL,aes(x=x1,y=y1) )\r\n    p1a<-p1a+geom_line(col=alpha(pointsCol,transparency), lwd = pointCex)\r\n    \r\n    #forecast\r\n    x2 = seq(length(prediction$x),length.out = length(prediction$mean))\r\n    y2 = as.numeric(prediction$mean)\r\n    \r\n    \r\n    p1a <- p1a + geom_line(inherit.aes = FALSE ,data = NULL, mapping = aes(x = x2, y = y2), col=alpha(forecastCol,transparency), lwd = pointCex)\r\n    \r\n    #conf intervals\r\n    \r\n    if(!is.null(lowerConfInterval))\r\n    {\r\n      lower2 = lower1 = as.numeric(prediction$lower[,1])\r\n      upper2 = upper1 = as.numeric(prediction$upper[,1])\r\n      id = x2\r\n      \r\n      names(lower2) = names(upper2) = names(lower1) = names(upper1)=  names(f_full) = id   \r\n      cf_full = as.character(f_full)\r\n      \r\n      p1a <- p1a + geom_ribbon( inherit.aes = FALSE , mapping = aes(x = id, ymin = lower1 , ymax = upper1), fill = \"blue4\", alpha = 0.25)\r\n    }\r\n    \r\n    if(upperConfInterval>0.01)\r\n    {\r\n      if(!is.null(lowerConfInterval))\r\n      {  \r\n        lower2 = as.numeric(prediction$lower[,2])\r\n        upper2 = as.numeric(prediction$upper[,2])\r\n      }\r\n      else\r\n      {  \r\n        lower1 = lower2 = as.numeric(prediction$lower[,1])\r\n        upper1 =upper2 = as.numeric(prediction$upper[,1])\r\n      } \r\n      \r\n      \r\n      id = x2\r\n      \r\n      names(lower2) = names(upper2) = names(lower1) = names(upper1)=  names(f_full) = id \r\n      cf_full = as.character(f_full)\r\n      \r\n      \r\n      p1a <- p1a + geom_ribbon( inherit.aes = FALSE , mapping = aes(x = id, ymin = lower2, ymax = upper2), fill = \"gray50\", alpha = 0.25)\r\n    }\r\n    \r\n    #design \r\n    p1a <- p1a + labs (title = pbiInfo, caption = NULL) + theme_bw() \r\n    p1a <- p1a + xlab(labTime) + ylab(labValue) \r\n    p1a <- p1a + scale_x_continuous(breaks = seq(1,length(prediction$x) + length(prediction$mean)-1, length.out = numTicks), labels = x_with_forcast_formatted) \r\n    p1a <- p1a +  theme(axis.text.x  = element_text(angle = getAngleXlabels(x_with_forcast_formatted), \r\n                                                    hjust=1, size = sizeTicks, colour = \"gray60\"),\r\n                        axis.text.y  = element_text(vjust = 0.5, size = sizeTicks, colour = \"gray60\"),\r\n                        plot.title  = element_text(hjust = 0.5, size = sizeWarn, colour = infoTextColor), \r\n                        axis.title=element_text(size =  sizeLabel),\r\n                        axis.text=element_text(size =  sizeTicks),\r\n                        panel.border = element_blank())\r\n    \r\n    \r\n    \r\n  }\r\n  \r\n  \r\n  \r\n}else{ \r\n  #empty plot\r\n  showWarnings = TRUE\r\n  pbiWarning1  = cutStr2Show(\"Not enough data points\", strCex = sizeWarn/6, partAvailable = 0.85)\r\n  pbiWarning<-paste(pbiWarning, pbiWarning1 , sep=\"<br>\")\r\n}\r\n\r\n#add warning as subtitle (or upper title since plotly has bug)\r\nif(showWarnings && !is.null(pbiWarning))\r\n{\r\n  p1a = ggplot() + labs (title = pbiWarning, caption = NULL) + theme_bw() +\r\n    theme(plot.title  = element_text(hjust = 0.5, size = sizeWarn), \r\n          axis.title=element_text(size =  sizeLabel),\r\n          axis.text=element_text(size =  sizeTicks),\r\n          panel.border = element_blank())\r\n  ggp <- plotly_build(p1a)\r\n}else{\r\n  \r\n  # massage some plot atributes to make transition from ggplot to plotly smooth \r\n  ggp <- plotly_build(p1a)\r\n  ggp$x$data[[1]]$text = paste(labTime, \": \", x_full, \"<br>\", labValue, \": \", round(y1,2) , sep =\"\" ) \r\n  ggp$x$data[[2]]$text = paste(labTime, \": \", f_full, \"<br>\", labValue, \": \", round(y2,2) , sep =\"\" ) \r\n  \r\n  if(length(ggp$x$data)>=3)\r\n  {\r\n    iii =  as.character(ggp$x$data[[3]]$x)\r\n    ggp$x$data[[3]]$text = paste(labTime, \": \", cf_full[iii], \"<br> lower: \", lower1[iii],\"<br> upper: \", upper1[iii], sep =\"\" ) \r\n  }\r\n  \r\n  if(length(ggp$x$data)>=4)\r\n  {\r\n    iii =  as.character(ggp$x$data[[4]]$x)\r\n    ggp$x$data[[4]]$text = paste(labTime, \": \", cf_full[iii], \"<br> lower: \", lower2[iii],\"<br> upper: \", upper2[iii], sep =\"\" ) \r\n  }\r\n  \r\n  \r\n  \r\n  ggp$x$layout$margin$l = ggp$x$layout$margin$l+10\r\n  \r\n  if(ggp$x$layout$xaxis$tickangle < -40)\r\n    ggp$x$layout$margin$b = ggp$x$layout$margin$b+40\r\n  \r\n}\r\n\r\n############# Create and save widget ###############\r\n\r\np <- ggp\r\n\r\ndisabledButtonsList <- list('toImage', 'sendDataToCloud', 'zoom2d', 'pan', 'pan2d', 'select2d', 'lasso2d', 'hoverClosestCartesian', 'hoverCompareCartesian')\r\np$x$config$modeBarButtonsToRemove = disabledButtonsList\r\n\r\np <- config(p, staticPlot = FALSE, editable = FALSE, sendData = FALSE, showLink = FALSE,\r\n            displaylogo = FALSE,  collaborate = FALSE, cloud=FALSE)\r\n\r\ninternalSaveWidget(p, 'out.html')\r\n\r\n\r\n\r\n# resolve bug in plotly (margin of 40 px)\r\nReadFullFileReplaceString('out.html', 'out.html', ',\"padding\":40,', ',\"padding\":0,')\r\n\r\nif(keepOutData)\r\n{\r\n  padNA1 = rep(NA,length(x_full))\r\n  padNA2 = rep(NA,length(f_full))\r\n  if(!exists(\"lower1\"))\r\n    lower1 = lower2 = upper1 = upper2 = padNA2;\r\n  \r\n  \r\n  lower1 = c(padNA1,lower1)\r\n  lower2 = c(padNA1,lower2)\r\n  upper1 = c(padNA1,upper1)\r\n  upper2 = c(padNA1,upper2)\r\n  \r\n  exportDF = data.frame(Date = as.character(c(x_full,f_full)),Value = c(y1,y2),\r\n                        lower1 = lower1,\r\n                        lower2 = lower2,\r\n                        upper1 = upper1,\r\n                        upper2 = upper2)\r\n  colnames(exportDF)[c(1,2)] = c(labTime,labValue)\r\n  \r\n  KeepOutDataInHTML(df = exportDF, htmlFile = 'out.html', exportMethod = exportMethod, limitExportSize = limitExportSize)\r\n}\r\n\r\n"}}}],"objects":{"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}},"settings_forecastPlot_params":{"displayName":"Forecasting settings","description":"Forecasting settings","properties":{"forecastLength":{"displayName":"Forecast length","description":"Number of data points to predict","type":{"numeric":true}},"confInterval1":{"displayName":"Confidence level","description":"Select first confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}},"confInterval2":{"displayName":"Confidence level #2","description":"Select additional confidence interval","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"0.2","value":"0.2"},{"displayName":"0.4","value":"0.4"},{"displayName":"0.5","value":"0.5"},{"displayName":"0.75","value":"0.75"},{"displayName":"0.8","value":"0.8"},{"displayName":"0.9","value":"0.9"},{"displayName":"0.95","value":"0.95"},{"displayName":"0.975","value":"0.975"},{"displayName":"0.98","value":"0.98"},{"displayName":"0.99","value":"0.99"},{"displayName":"0.995","value":"0.995"},{"displayName":"0.999","value":"0.999"}]}}}},"settings_seasonality_params":{"displayName":"Seasonality","properties":{"show":{"type":{"bool":true}},"targetSeason":{"displayName":"Target seasonal factor","description":"Recommended seasonal factor. Incompatible inputs are ignored","type":{"enumeration":[{"displayName":"automatic","value":"automatic"},{"displayName":"manual","value":"manual"},{"displayName":"hour","value":"hour"},{"displayName":"day","value":"day"},{"displayName":"week","value":"week"},{"displayName":"month","value":"month"},{"displayName":"quarter","value":"quarter"},{"displayName":"year","value":"year"}]}},"knownFrequency":{"displayName":"Frequency","description":"Number of samples per season. Incompatible inputs are ignored.","type":{"numeric":true}}}},"settings_model_params":{"displayName":"Model Customization","properties":{"maxp":{"displayName":"Maximal p","description":"Maximal order of the autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxq":{"displayName":"Maximal q","description":"Maximal order of the moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxP":{"displayName":"Maximal P","description":"The maximal order of the seasonal autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxQ":{"displayName":"Maximal Q","description":"The maximal order of the seasonal moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"maxd":{"displayName":"Maximal d","description":"Maximal degree of differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"maxD":{"displayName":"Maximal D","description":"Maximal degree of seasonal differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"allowDrift":{"displayName":"Allow drift","description":"Allows the ARIMA model to include a linear drift term","type":{"bool":true}},"allowMean":{"displayName":"Allow mean","description":"Allows the ARIMA model include a mean term","type":{"bool":true}},"stepwiseSelection":{"displayName":"Stepwise selection","description":"TRUE performs a stepwise selection (faster), FALSE searches over all models (slow)","type":{"bool":true}},"boxCoxTransform":{"displayName":"Box-Cox transformation","description":"Family of transformations that includes logarithms and power transformations. The outcome depends on the `lambda` parameter. Recommended when the data show variation that increases or decreases with the level of the series","type":{"enumeration":[{"displayName":"off","value":"off"},{"displayName":"automatic","value":"automatic"},{"displayName":"manual","value":"manual"}]}},"lambda":{"displayName":"lambda","description":"Box-Cox transformation parameter","type":{"numeric":true}}}},"settings_userModel_params":{"displayName":"User defined model","properties":{"show":{"type":{"bool":true}},"p":{"displayName":"p","description":"Order of the autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"q":{"displayName":"q","description":"Order of the moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"P":{"displayName":"P","description":"Order of the seasonal autoregressive component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"Q":{"displayName":"Q","description":"Order of the seasonal moving average component","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"},{"displayName":"3","value":"3"}]}},"d":{"displayName":"d","description":"Degree of differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}},"D":{"displayName":"D","description":"Degree of seasonal differencing","type":{"enumeration":[{"displayName":"0","value":"0"},{"displayName":"1","value":"1"},{"displayName":"2","value":"2"}]}}}},"settings_graph_params":{"displayName":"Graphical parameters","properties":{"dataCol":{"displayName":"History data color","type":{"fill":{"solid":{"color":true}}}},"forecastCol":{"displayName":"Forecast data color","type":{"fill":{"solid":{"color":true}}}},"percentile":{"displayName":"Opacity","type":{"numeric":true}},"weight":{"displayName":"Line width","type":{"numeric":true}}}},"settings_additional_params":{"displayName":"Info","properties":{"show":{"type":{"bool":true}},"textSize":{"displayName":"Font size","description":"Font size used to show information","type":{"numeric":true}},"textColor":{"displayName":"Text color","description":"Color used to show information","type":{"fill":{"solid":{"color":true}}}},"infoCriteria":{"displayName":"Output information criteria","description":"Used only for info, does not influence the results. Select one option: Akaike's Information Criterion (AIC), Corrected Akaike's Information Criterion (AICc), or Schwarz's Bayesian Information Criterion (BIC) ","type":{"enumeration":[{"displayName":"none","value":"none"},{"displayName":"AIC","value":"AIC"},{"displayName":"BIC","value":"BIC"},{"displayName":"AICc","value":"AICc"}]}}}},"settings_export_params":{"displayName":"Export data","description":"Export results","properties":{"show":{"type":{"bool":true}},"limitExportSize":{"displayName":"Maximum exported rows","description":"Limit number of rows","type":{"enumeration":[{"displayName":"1000","value":"1000"},{"displayName":"10000","value":"10000"},{"displayName":"50000","value":"50000"},{"displayName":"unlimited","value":"100000"}]}},"method":{"displayName":"Method","description":"Method","type":{"enumeration":[{"displayName":"copy to clipboard","value":"copy"},{"displayName":"download (only service)","value":"download"}]}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"zoo","displayName":"zoo: S3 Infrastructure for Regular and Irregular Time Series","url":"https://cran.r-project.org/web/packages/zoo/index.html"},{"name":"scales","displayName":"scales: Scale Functions for Visualization","url":"https://cran.r-project.org/web/packages/scales/index.html"},{"name":"reshape2","displayName":"reshape2: Flexibly Reshape Data: A Reboot of the Reshape Package","url":"https://cran.r-project.org/web/packages/reshape2/index.html"},{"name":"forecast","displayName":"forecast: Forecasting Functions for Time Series and Linear Models","url":"https://cran.r-project.org/web/packages/forecast/index.html"},{"name":"plotly","displayName":"Plotly","url":"https://cran.r-project.org/web/packages/plotly/index.html"},{"name":"htmlwidgets","displayName":"HTML Widgets","url":"https://cran.r-project.org/web/packages/htmlwidgets/index.html"},{"name":"XML","displayName":"XML","url":"https://cran.r-project.org/web/packages/XML/index.html"},{"name":"caTools","displayName":"caTools","url":"https://cran.r-project.org/web/packages/caTools/index.html"}]},"stringResources":{},"content":{"js":"var powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){function e(t,e,i){void 0===t&&(t=[]);var n=t;return s(n),e&&(n.identityFields=e),i&&(n.source=i),n}function s(t,e){t.grouped=e?function(){return e}:function(){return i(t)}}function i(t){for(var e,s=[],i=0,n=t.length;n>i;i++){var a=t[i];if(!e||e.identity!==a.identity){if(e={values:[]},a.identity){e.identity=a.identity;var r=a.source;void 0!==r.groupName?e.name=r.groupName:r.displayName&&(e.name=r.displayName)}s.push(e)}e.values.push(a)}return s}t.createValueColumns=e,t.setGrouped=s,t.groupValues=i}(e=t.DataViewTransform||(t.DataViewTransform={}))}(e=t.dataview||(t.dataview={}))}(e=t.utils||(t.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){function e(t,e){if(!t||!t.length)return-1;var s=t[0];if(s.values&&s.values.length>0)for(var n=0,a=s.values.length;a>n;++n){var r=s.values[n];if(r&&r.source&&i(r.source,e))return n}return-1}function s(t,e){if(t&&t.length)for(var s=0,n=t.length;n>s;s++)if(i(t[s].source,e))return s;return-1}function i(t,e){var s=t.roles;return s&&s[e]}function n(t,e){return null!=t&&null!=t.metadata&&t.metadata.columns&&t.metadata.columns.some(function(t){return t.roles&&void 0!==t.roles[e]})}function a(t,e){return t&&t.source&&t.source.roles&&t.source.roles[e]===!0}t.getMeasureIndexOfRole=e,t.getCategoryIndexOfRole=s,t.hasRole=i,t.hasRoleInDataView=n,t.hasRoleInValueColumn=a}(e=t.DataRoleHelper||(t.DataRoleHelper={}))}(e=t.dataview||(t.dataview={}))}(e=t.utils||(t.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){function e(t,e,s){if(!t)return s;var i=t[e];return void 0===i?s:i}function s(t,s,i){var n=e(t,s);return n&&n.solid?n.solid.color:i}t.getValue=e,t.getFillColorByPropertyName=s}(e=t.DataViewObject||(t.DataViewObject={}))}(e=t.dataview||(t.dataview={}))}(e=t.utils||(t.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){var e;!function(e){function s(e,s,i){return e?t.DataViewObject.getValue(e[s.objectName],s.propertyName,i):i}function i(t,e,s){return t&&t[e]?t[e]:s}function n(t,e,i){var n=s(t,e);return n&&n.solid?n.solid.color:i}function a(t,e,i){var n=s(t,e,i);return n&&n.solid?n.solid.color:void 0===n||null===n||\"object\"==typeof n&&!n.solid?i:n}e.getValue=s,e.getObject=i,e.getFillColor=n,e.getCommonValue=a}(e=t.DataViewObjects||(t.DataViewObjects={}))}(e=t.dataview||(t.dataview={}))}(e=t.utils||(t.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(e){var s;!function(e){var s;!function(e){var s,i=t.extensibility.utils.dataview.DataRoleHelper;!function(t){function e(t,e,s){if(t.categories&&t.categories.length>0){var n=t.categories[0];return n.source&&i.hasRole(n.source,e)&&i.hasRole(n.source,s)}return!1}function s(t){return void 0!==t.groupName?t.groupName:t.queryName}function n(t){var e=r(t);return null!=e&&e.imageUrl===!0}function a(t){var e=r(t);return null!=e&&e.webUrl===!0}function r(t){return t&&t.type&&t.type.misc}function o(t){return t&&t.metadata&&t.metadata.columns&&t.metadata.columns.length?t.metadata.columns.some(function(t){return n(t)===!0}):!1}t.categoryIsAlsoSeriesRole=e,t.getSeriesName=s,t.isImageUrlColumn=n,t.isWebUrlColumn=a,t.getMiscellaneousTypeDescriptor=r,t.hasImageUrlColumn=o}(s=e.converterHelper||(e.converterHelper={}))}(s=e.dataview||(e.dataview={}))}(s=e.utils||(e.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){var e=function(){function e(){}return e.getDefault=function(){return new this},e.createPropertyIdentifier=function(t,e){return{objectName:t,propertyName:e}},e.parse=function(e){var s,i=this.getDefault();if(!e||!e.metadata||!e.metadata.objects)return i;s=i.getProperties();for(var n in s)for(var a in s[n]){var r=i[n][a];i[n][a]=t.DataViewObjects.getCommonValue(e.metadata.objects,s[n][a],r)}return i},e.isPropertyEnumerable=function(t){return!e.InnumerablePropertyPrefix.test(t)},e.enumerateObjectInstances=function(t,e){var s=t&&t[e.objectName];if(!s)return[];var i={objectName:e.objectName,selector:null,properties:{}};for(var n in s)s.hasOwnProperty(n)&&(i.properties[n]=s[n]);return{instances:[i]}},e.prototype.getProperties=function(){var t=this,s={},i=Object.keys(this);return i.forEach(function(i){if(e.isPropertyEnumerable(i)){var n=Object.keys(t[i]);s[i]={},n.forEach(function(t){e.isPropertyEnumerable(i)&&(s[i][t]=e.createPropertyIdentifier(i,t))})}}),s},e}();e.InnumerablePropertyPrefix=/^_/,t.DataViewObjectsParser=e}(e=t.dataview||(t.dataview={}))}(e=t.utils||(t.utils={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var __extends=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var s in e)e.hasOwnProperty(s)&&(t[s]=e[s])};return function(e,s){function i(){this.constructor=e}t(e,s),e.prototype=null===s?Object.create(s):(i.prototype=s.prototype,new i)}}(),powerbi;!function(t){var e;!function(t){var e;!function(t){var e;!function(t){\"use strict\";function e(){r=0}function s(){return 0===r}function i(t,e){var s=[];if(t&&t.hasChildNodes()){for(var i=t.children,a=0;a<i.length;a++){var r=void 0;r=\"script\"===i.item(a).nodeName.toLowerCase()?n(i.item(a)):i.item(a).cloneNode(!0),e.appendChild(r),s.push(r)}return s}}function n(t){for(var e=document.createElement(\"script\"),s=t.attributes,i=0;i<s.length;i++)e.setAttribute(s[i].name,s[i].textContent),\"src\"===s[i].name.toLowerCase()&&(r++,e.onload=function(){r--});return e.innerHTML=t.innerHTML,e}function a(){var t=window.setInterval(function(){s()&&(window.clearInterval(t),window.hasOwnProperty(\"HTMLWidgets\")&&window.HTMLWidgets.staticRender&&window.HTMLWidgets.staticRender())},100)}var r=0;t.ResetInjector=e,t.injectorReady=s,t.ParseElement=i,t.RunHTMLWidgetRenderer=a}(e=t.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(t.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(e=t.visual||(t.visual={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(e){var s;!function(e){var s;!function(e){\"use strict\";function s(t,e,s){return e>t?e:t>s?s:t}var i=t.extensibility.utils.dataview.DataViewObjectsParser;e.inMinMax=s;var n=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.settings_forecastPlot_params=new a,e.settings_seasonality_params=new r,e.settings_model_params=new o,e.settings_userModel_params=new u,e.settings_graph_params=new l,e.settings_additional_params=new c,e.settings_export_params=new p,e}return __extends(e,t),e}(i);e.VisualSettings=n;var a=function(){function t(){this.forecastLength=10,this.confInterval1=\"0.85\",this.confInterval2=\"0.95\"}return t}();e.SettingsForecastPlotParams=a;var r=function(){function t(){this.show=!0,this.targetSeason=\"automatic\",this.knownFrequency=12}return t}();e.SettingsSeasonalityParams=r;var o=function(){function t(){this.maxp=\"3\",this.maxq=\"3\",this.maxP=\"2\",this.maxQ=\"2\",this.maxd=\"2\",this.maxD=\"1\",this.allowDrift=!0,this.allowMean=!0,this.stepwiseSelection=!0,this.boxCoxTransform=\"off\",this.lambda=.1}return t}();e.SettingModelParams=o;var u=function(){function t(){this.show=!1,this.p=\"1\",this.q=\"1\",this.P=\"1\",this.Q=\"1\",this.d=\"1\",this.D=\"0\"}return t}();e.SettingsUserModelParams=u;var l=function(){function t(){this.dataCol=\"blue\",this.forecastCol=\"orange\",this.percentile=40,this.weight=10}return t}();e.SettingsGraphParams=l;var c=function(){function t(){this.show=!0,this.textSize=12,this.textColor=\"brown\",this.infoCriteria=\"none\"}return t}();e.SettingsAdditionalParams=c;var p=function(){function t(){this.show=!1,this.limitExportSize=\"10000\",this.method=\"copy\"}return t}();e.SettingsExportParams=p}(s=e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(s=e.visual||(e.visual={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(e){var s;!function(e){var s;!function(e){\"use strict\";var s=!1,i=[t.VisualUpdateType.Resize,t.VisualUpdateType.ResizeEnd,t.VisualUpdateType.Resize+t.VisualUpdateType.ResizeEnd],n=function(){function t(t){t&&t.element&&(this.rootElement=t.element),this.headNodes=[],this.bodyNodes=[]}return t.prototype.update=function(e){if(e&&e.type&&e.viewport&&e.dataViews&&0!==e.dataViews.length&&e.dataViews[0]){var s=e.dataViews[0];this.settings=t.parseSettings(s);var n=null;s.scriptResult&&s.scriptResult.payloadBase64&&(n=s.scriptResult.payloadBase64),-1===i.indexOf(e.type)?n&&this.injectCodeFromPayload(n):this.onResizing(e.viewport)}},t.prototype.onResizing=function(t){},t.prototype.injectCodeFromPayload=function(t){if(e.ResetInjector(),t){var i=document.createElement(\"html\");try{i.innerHTML=window.atob(t)}catch(n){return}if(s||0===this.headNodes.length){for(;this.headNodes.length>0;){var a=this.headNodes.pop();document.head.removeChild(a)}var r=i.getElementsByTagName(\"head\");if(r&&r.length>0){var o=r[0];this.headNodes=e.ParseElement(o,document.head)}}for(;this.bodyNodes.length>0;){var a=this.bodyNodes.pop();this.rootElement.removeChild(a)}var u=i.getElementsByTagName(\"body\");if(u&&u.length>0){var l=u[0];this.bodyNodes=e.ParseElement(l,this.rootElement)}e.RunHTMLWidgetRenderer()}},t.parseSettings=function(t){return e.VisualSettings.parse(t)},t.prototype.enumerateObjectInstances=function(t){var s=t.objectName,i=[];switch(s){case\"settings_forecastPlot_params\":i.push({objectName:s,properties:{forecastLength:Math.round(e.inMinMax(this.settings.settings_forecastPlot_params.forecastLength,1,1e6)),confInterval1:this.settings.settings_forecastPlot_params.confInterval1,confInterval2:this.settings.settings_forecastPlot_params.confInterval2},selector:null});break;case\"settings_seasonality_params\":i.push({objectName:s,properties:{show:this.settings.settings_seasonality_params.show,targetSeason:this.settings.settings_seasonality_params.targetSeason},selector:null}),\"manual\"===this.settings.settings_seasonality_params.targetSeason&&i.push({objectName:s,properties:{knownFrequency:e.inMinMax(this.settings.settings_seasonality_params.knownFrequency,2,1e6)},selector:null});break;case\"settings_model_params\":i.push({objectName:s,properties:{maxp:this.settings.settings_model_params.maxp,maxd:this.settings.settings_model_params.maxd,maxq:this.settings.settings_model_params.maxq}}),this.settings.settings_seasonality_params.show&&i.push({objectName:s,properties:{maxP:this.settings.settings_model_params.maxP,maxD:this.settings.settings_model_params.maxD,maxQ:this.settings.settings_model_params.maxQ}}),i.push({objectName:s,properties:{allowDrift:this.settings.settings_model_params.allowDrift,allowMean:this.settings.settings_model_params.allowMean,boxCoxTransform:this.settings.settings_model_params.boxCoxTransform}}),\"manual\"===this.settings.settings_model_params.boxCoxTransform&&i.push({objectName:s,properties:{lambda:e.inMinMax(this.settings.settings_model_params.lambda,-.5,1.5)}}),i.push({objectName:s,properties:{stepwiseSelection:this.settings.settings_model_params.stepwiseSelection},selector:null});break;case\"settings_userModel_params\":i.push({objectName:s,properties:{show:this.settings.settings_userModel_params.show,p:this.settings.settings_userModel_params.p,d:this.settings.settings_userModel_params.d,q:this.settings.settings_userModel_params.q},selector:null}),this.settings.settings_seasonality_params.show&&i.push({objectName:s,properties:{P:this.settings.settings_userModel_params.P,D:this.settings.settings_userModel_params.D,Q:this.settings.settings_userModel_params.Q},selector:null});break;case\"settings_graph_params\":i.push({objectName:s,properties:{dataCol:this.settings.settings_graph_params.dataCol,forecastCol:this.settings.settings_graph_params.forecastCol,percentile:this.settings.settings_graph_params.percentile,weight:this.settings.settings_graph_params.weight},selector:null});break;case\"settings_additional_params\":i.push({objectName:s,properties:{show:this.settings.settings_additional_params.show,textSize:this.settings.settings_additional_params.textSize,textColor:this.settings.settings_additional_params.textColor,infoCriteria:this.settings.settings_additional_params.infoCriteria},selector:null});break;case\"settings_export_params\":i.push({objectName:s,properties:{show:this.settings.settings_export_params.show,limitExportSize:this.settings.settings_export_params.limitExportSize,method:this.settings.settings_export_params.method},selector:null})}return i},t}();e.Visual=n}(s=e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML||(e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={}))}(s=e.visual||(e.visual={}))}(e=t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){var e;!function(e){var s;!function(e){e.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML={name:\"PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML\",displayName:\"Forecasting with ARIMA\",\"class\":\"Visual\",version:\"1.2.1\",apiVersion:\"1.11.0\",create:function(e){return new t.extensibility.visual.PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML.Visual(e)},custom:!0}}(s=e.plugins||(e.plugins={}))}(e=t.visuals||(t.visuals={}))}(powerbi||(powerbi={}));","css":".visual-PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML .rcv_autoScaleImageContainer{position:relative}.visual-PBI_CV_AD348DC9_41C4_4867_B19O_53F9RDC6IEAS_HTML .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAScwAAEnMBjCK5BwAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xMzQDW3oAAAJHSURBVDhPrZFdSJNRHMaPFkRoscCLiO6ELrrIWdkmLRtkEAjdSHjrRRAIRfQhCIFSSoXp6+xdUBAJpi1lH8QuNIIupA8JMsdM+4DoJhzIQsyWtb1Pzzmdzea0lvaDh53zf8//dz4mJB0e087Y1IRgUpzDlKjT03+HsseMW44xIcopA6Xj6uNqyBJOiTZmSElfC6dakAftoUi9HuYI3zIuZpSnNNSCv0CZm4GeLgrxRlTJk8kaZbUcf1IL/gBFdubz8sJJcZ0JICp2qvx6y6N6WQ6U2JgPUraScJqSiSXp08tyoGQsLev0v8gWRh85mtj8TpcU8k/hJknERLEuZaDkjhSd7RlF5PYxLPSXAqcKt6iPUshGi4JmVdDUtD4sYD3K+nFdUlDUctk/jkZjADO3nEjc2wNv7/3sE3q9V6v1NAMAEX9iK+JPgS5JWf2lwTHMhaqRGtiL52YDjPCr5d9QTzNIIU+5jlFXZpP9ys3g7Fy/E6mhSvT4/EqUjmqSLBXKq+phWriBDRvPm+HZZGgfEg8O4VrgZZZsRSEaxHpV/A25QeRMWXcqUAmjNzzD5hiTYOJMkGlhFm+YFqKpqMTy7bbQVxbD3V3PcLGkhhuUIuCYt8L7k++bXYfZuIPZxmzS7bloocsKH4hbw+4ELmyuw8iRBfgd8wg5geGDX+TJ5ZvmhRQG205UWL7y74nTxdt1WYGThVv1MH88N8yRb8Gqrz8GnR91aW0YXV1PrYAD/sbaCl1aG/LKns52dHi6GXPV0br/iRA/AZqz0QSBTrQ6AAAAAElFTkSuQmCC"}}